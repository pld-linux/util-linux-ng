Mount has to read /proc/partitions in one gulp. It doesn't. Failed for me 
after a hard powerdown (oops) and the resulting fsck-the-world frenzy on 
startup, before the mount -a. Failure cause is identical (getting out of 
sync with the text at the 1K boundary), but failure mode not quite so 
drastic as it doesn't bail out like fsck does.

--- util-linux-2.11y/disk-utils/blockdev.c.procpartitions	2002-03-08 17:57:02.000000000 -0500
+++ util-linux-2.11y/disk-utils/blockdev.c	2003-01-13 14:28:41.000000000 -0500
@@ -290,6 +290,7 @@
 	char ptname[200];
 	char device[210];
 	int ma, mi, sz;
+	char iobuf[32*1024];
 
 	procpt = fopen(PROC_PARTITIONS, "r");
 	if (!procpt) {
@@ -297,6 +298,7 @@
 			progname, PROC_PARTITIONS);
 		exit(1);
 	}
+	setvbuf(procpt, iobuf, _IOFBF, sizeof(iobuf));
 
 	while (fgets(line, sizeof(line), procpt)) {
 		if (sscanf (line, " %d %d %d %[^\n ]",
--- util-linux-ng-2.17.2/fdisk/fdisk.c.orig	2010-03-22 09:21:34.000000000 +0100
+++ util-linux-ng-2.17.2/fdisk/fdisk.c	2010-05-09 12:31:53.050933394 +0200
@@ -2844,12 +2844,14 @@
 	char line[128], ptname[128], devname[256];
 	int ma, mi;
 	unsigned long long sz;
+	char iobuf[32*1024];
 
 	procpt = fopen(PROC_PARTITIONS, "r");
 	if (procpt == NULL) {
 		fprintf(stderr, _("cannot open %s\n"), PROC_PARTITIONS);
 		return;
 	}
+	setvbuf(procpt, iobuf, _IOFBF, sizeof(iobuf));
 
 	while (fgets(line, sizeof(line), procpt)) {
 		if (sscanf (line, " %d %d %llu %128[^\n ]",
